{
  "hash": "b15f2e552b69c00dc4dfffc88fade9f7",
  "result": {
    "markdown": "---\ntitle: \"Midterm 1\"\nauthor: \"Alexus Lawrence\"\ndate: \"2023-04-13\"\ncategories: [news, code, analysis]\nimage: \"image.jpg\"\n---\n\n\n\n### Midterm 1 \n\nWelcome to the first part of my midterm. In this post I will be demonstrating my understanding of multiple tasks that we have learned so far.\n\n**Directions:** \nWrite a blog post where you demonstrate your ability to use these basic programming concepts in R.\n\n**R objects:** show that you understand and can create/use objects of various types, including at least: character/string, numeric, integer, logical, data.frame, and list. Show that you can index objects appropriately (e.g., locate elements of an object, change elements of an object etc.)\n\n**Logical operations:** show that you understand and can use logical operators in R (e.g., == | > < >= <=)\n\n**Loops:** Show that you understand the components of a for loop, and that you can use a for loop.\n\n**Functions:** Show that you understand the syntax for declaring your own function, and that you can declare and run your own custom function to accomplish some task (you choose what the function does).\n\n\n\n## R-objects \n\nR- objects are words that \" identifies and store the values of some data for later use\"\nObjects can contain numbers, words , full stops and underscores . Sometimes objects are referred to as variables. \n\n**Character/string**\n\nA character is defined as a data type representing strings of text \n\nI will give you an example of strings and also non-examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Strings are encased by quotes , this can look like:\n\n\"1\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"\n```\n:::\n\n```{.r .cell-code}\n\"A,B,C\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A,B,C\"\n```\n:::\n\n```{.r .cell-code}\n# In comparison , when a numbers or texts are not encased by quotes they are not consider strings\n\n1 # This would be simply interpreted as a numeric value \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nA # This will be considered a character because it is a text but not a string \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'A' not found\n```\n:::\n:::\n\n\n\n**Type of ()**\n\nThe type of function is a function used when trying to determine the data type being used. We can see this using the same strings, characters and double that I used above. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(\"1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(\"A,B,C\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ntypeof (A)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in typeof(A): object 'A' not found\n```\n:::\n:::\n\nNotice that when using the typeof() function above, it outputted the data types. However, you may be puzzled by the error that we see for A. This error states **\"Error in typeof(A) : object 'A' not found\"** , which basically means that the letter A by itself is considered an object, therefore you would need to assign something to it. \n\nNow lets discuss the other results,\n\nFor the first result , 1 is considered a **double** , this is because r recognizes any number with a decimal as a double for example 1.0 is the same as 1. Therefore, 1 is a double. I will get into numeric values : doubles and integers in the next section. \n\nFor A,B,C it is a character string because the letters are encased by quotes and the number 1 without quotation is considered a character because it is not surrounded by quotes. \n\n\n# Numeric \n\nNumeric is defined as a data type that represents integers and doubles. \n\n**is.numeric() with integers, doubles, strings**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Numeric values can be both doubles and integers, using the is.numeric() function will help with the confusion surround numeric vs non-numeric values \n\nis.numeric(1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(3.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(\"1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(\"3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\nAfter using the is.numeric function it returns true or false values regarding if something is numeric or not. **Remember that if a number is encased by quotes, it is a character, hence the false output of line 82-83**\n\nR is a great program and is lenient to its coders , there is a function called **as.numeric()** in which you can false R to view these numbers as numeric! Let's see it in live action. \n\n**as.numeric() with integers,doubles and strings**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nas.numeric(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nas.numeric(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nas.numeric(3.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nas.numeric(\"1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nas.numeric(\"3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\nAs you can see above R recognized these values as numeric.\n\nBut.... There is also another way! \n\n**is.numeric() with L for numbers **\n\nIf you would like a number that is not encased by quotes to be viewed as numeric you can also place an L after the number. **Use the is.numeric() function**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(2L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThese numbers are considered numeric and not characters because the **L** tells R that the number is numeric. \n\n\nBut.... What about characters like A, B, C or D?? Can those be numeric ?? Let's try it out. \n\n**Testing out as.numeric() with characters**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(a)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'a' not found\n```\n:::\n\n```{.r .cell-code}\nas.numeric(b)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'b' not found\n```\n:::\n:::\n\nAs you can see above , even when using the as.numeric function characters will not be considered numeric because they're not!\n\nWell... how about imaginary numbers , are they considered numeric? If not, can be changed into numeric values using the as.numeric function? Let's try it out!\n\n**is.numeric() with imaginary numbers**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(3i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(5i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(6i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThese false values outputted above demonstrate that imaginary numbers are not considered numeric values. Let's see what happens when we try to convert them into numeric values using the **as.numeric()** function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(3i)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: imaginary parts discarded in coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nas.numeric(5i)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: imaginary parts discarded in coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nas.numeric(6i)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: imaginary parts discarded in coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nas.numeric(6+6i)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: imaginary parts discarded in coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\nWow, look at that! The warning states **\"imaginary parts discarded in coercion**, this means that R does not see imaginary numbers as numeric values but also discarded their imaginary parts to output the numeric value of \"0\". Additionally, when inputting the 6+6i inside of the as.numeric() function, it only outputted the 6 and discarded the imaginary 6i. \n\n\n# Logical \n\nLogical is defined as a data type that represents true or false values. Some programs will also refer to logical as **Boolean**, for the sake of this midterm we will just use logical. \n\nSimilar to as.numeric , the logical data type has **as.logical** function that can help determine values as logical. **You can also determine logical yourself by using T to  demonstrate true values and F to demonstrate false values** \n\n**It is important that with the as.logical data type , zeroes are referred to as false, while non zeroes are referred to as true**\n\nFor example: \n(I will start off simple then use more complex examples)\n\n**Zeroes vs non-zeroes with as.logical**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.logical(0) #zereos are consider false\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nas.logical(1) #non-zero , true value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nas.logical(2) #non-zero, true value \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n**List of True and False values**\n\nWe can make a list of logical true values and false values using the list() function. \n\n\n**True values** \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrue_logical<-list(           #Assign it to a variable \n  full = TRUE,                #Full = is used to make the full list true \n  abbreviated = T,            #True or false logical values are abbreviated to T&F respectfully \n  integer = as.logical(5),     #Using the as.logical for the number 5 and it is a non-zero, it will be a true value\n  equation = \"A\" == \"A\")     #Will be a true value because A does equal A and quotations needed for the character (A) \n\n\n\nstr(true_logical)      #Return the string true_logical\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ full       : logi TRUE\n $ abbreviated: logi TRUE\n $ integer    : logi TRUE\n $ equation   : logi TRUE\n```\n:::\n:::\n\n\n**False values**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfalse_logical<-list(           #Assign it to a variable \n  full = FALSE,                #Full = is used to make the full list false \n  abbreviated = F,            #True or false logical values are abbreviated to T&F respectfully \n  integer = as.logical(0),     #Using the as.logical for the number zero, it will be a false value\n  equation = \"C\" == \"D\")     #Will be a false value because C doesn't equal D , quotations needed for character/strings\n\n\nstr(false_logical)       #return false_logical\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ full       : logi FALSE\n $ abbreviated: logi FALSE\n $ integer    : logi FALSE\n $ equation   : logi FALSE\n```\n:::\n:::\n\n\n**Logical with operator**\nYou can use logical function with operators as well , for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.logical(10 > 11)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nas.logical(9 > 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nas.logical(12 < 14)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n# Data.frame \n\nData.frame is defined as \"data type for storing tabular data\". \n**Data tabular data:** \"Data in a rectangular table format, where each row has an entry for each column.\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\nItem = 1:10,    \nDescription = c(\"eggs\", \"cheese\", \"milk\", \"tropicana juice\", \"butter\", \"bagels\", \"bread\", \"rice\", \"beans\", \"gallon of water\"), \nPrice = c (\"2.99\", \"3.00\", \"5.00\", \"4.00\", \"1.99\", \"6.00\", \"8.99\", \"10.00\", \"3.50\", \"2.50\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Item     Description Price\n1     1            eggs  2.99\n2     2          cheese  3.00\n3     3            milk  5.00\n4     4 tropicana juice  4.00\n5     5          butter  1.99\n6     6          bagels  6.00\n7     7           bread  8.99\n8     8            rice 10.00\n9     9           beans  3.50\n10   10 gallon of water  2.50\n```\n:::\n\n```{.r .cell-code}\n#when using data.frame the name of the column goes on the left side of the equal sign and then the row info on the right side \n```\n:::\n\n\n# List\n\nList is defined as \"A container data type that allows items with different data types to be grouped together.\"\n\nWe can use some of the different data types that I included earlier in the blog.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\ncelebrityname = c(\"Chloe Bailey\", \"Beyonce\", \"Future\", \"Jay Z\"), #using the c to make the string \ninteger = 1:30,  #use the integer type\nstr(\"I love celebrities\"), #use str to make a string\nlist_withtandf= list(\"A==A\",\"is\", TRUE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr \"I love celebrities\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n$celebrityname\n[1] \"Chloe Bailey\" \"Beyonce\"      \"Future\"       \"Jay Z\"       \n\n$integer\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30\n\n[[3]]\nNULL\n\n$list_withtandf\n$list_withtandf[[1]]\n[1] \"A==A\"\n\n$list_withtandf[[2]]\n[1] \"is\"\n\n$list_withtandf[[3]]\n[1] TRUE\n```\n:::\n:::\n\n\n# Vector \nVector is defined as \"A type of data structure that collects values with the same data type, like T/F values, numbers, or strings.\"\n\nYou can use the c() to make different list including different data types from the definition\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrinks <- c(\"water\", \"tropicana juice\", \"milk\", \"sorrel\", \"orange juice\", \"smoothie\")\nintegers <- 1:6\n\ndrinks     #call drinks\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"water\"           \"tropicana juice\" \"milk\"            \"sorrel\"         \n[5] \"orange juice\"    \"smoothie\"       \n```\n:::\n\n```{.r .cell-code}\nintegers    #call integers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6\n```\n:::\n:::\n\n\n**Use brackets to select from list**\n\nWe can use the brackets [] to select certain things from the list \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrinks[4]  #selecting the 4th item from the drinks list \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sorrel\"\n```\n:::\n\n```{.r .cell-code}\nintegers[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n**Built-in vectors**\n\nThere are also built in vectors such as LETTERS and we can select from it as well\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLETTERS\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n```\n:::\n\n```{.r .cell-code}\nLETTERS[16]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"P\"\n```\n:::\n:::\n\n\n## Logical Operations \n\nLogical operator can include arithmetic operator , relational operator and logical operators. I will show my understanding of all these operators below while educating you on how to use them. Let's start !\n\n**Arithmetic Operator**\n\nA type of data structure that collects values with the same data type, like T/F values, numbers, or strings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nArithmetic_operators <- c(\"*\", \"+\",\"-\",\"/\",\"%%\",\"^\")    #Assigning arithmetic operators to a variable so that you can visually see the list of them\nArithmetic_operators\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"*\"  \"+\"  \"-\"  \"/\"  \"%%\" \"^\" \n```\n:::\n\n```{.r .cell-code}\n1*4 #* is a arithmetic operator used for multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n7+8 # + is a arithmetic operator used for addition \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n\n```{.r .cell-code}\n9-0 # - is an arithmetic operator used for subtraction \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\n16/4 # / is an arithmetic operator used for division \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n25%%6 # %% is used to find the remainder \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n9^2   # ^ is used to represent an exponent \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 81\n```\n:::\n\n```{.r .cell-code}\n#Now, let's run this code ! \n```\n:::\n\n\n**Relational operator**\n\nRelational operators are operators that are used to compare or show the relationships between objects\n\n::: {.cell}\n\n```{.r .cell-code}\nrelational_operator <- c(\"==\",\"!=\",\">\",\">=\",\"<\",\"<=\",\"%in%\") #assigning it to a variable so you can have list \nrelational_operator\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"==\"   \"!=\"   \">\"    \">=\"   \"<\"    \"<=\"   \"%in%\"\n```\n:::\n\n```{.r .cell-code}\n\"C\"==\"C\" #== is a operator used as \"equal to\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n\"B!\"=\"Z\" # != is an operator that is used to represent \"not equal to\" \n8>4 # > is an operator that is used to represent \"greater than\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n16>=15 # >= is an operator that is used to represent \"greater than or equal to\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n15<16 # < is an operator used to represent \"less than\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n14<=3 # <= is an operator used to represent \"less than or equal to \"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n\"sorrel\"%in%drinks #%in% is an operator to represent \"match\", which is basically to \"match\" objects to vectors or list \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n**Logical operators**\nLogical operators are used to compare objects in vectors \nThese can only be used for numeric, logical or complex types\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_operators <-c(\"&\",\"|\",\"&&\",\"||\",\"!\")\nlogical_operators\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"&\"  \"|\"  \"&&\" \"||\" \"!\" \n```\n:::\n\n```{.r .cell-code}\nc(9,8,7) & c(9,10,11) == c(9,8,2) #& and compares each element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(T,F,F,F,F,T)|c(F,T,T,T,T,F) == c(F,F,T,T,F,T) # \"|\" compares each element \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nc(9+8i,6+7i,10+2i) && c(9+6i,7+6i,2+10i) == F  #&& compares the first element , this example is using complex types\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in c(9 + (0+8i), 6 + (0+7i), 10 + (0+2i)) && c(9 + (0+6i), 7 + (0+6i), :\n'length(x) = 3 > 1' in coercion to 'logical(1)'\n\nWarning in c(9 + (0+8i), 6 + (0+7i), 10 + (0+2i)) && c(9 + (0+6i), 7 + (0+6i), :\n'length(x) = 3 > 1' in coercion to 'logical(1)'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nc(T,T,F) || c(T,F,F) == T  # compares the first element \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in c(T, T, F) || c(T, F, F) == T: 'length(x) = 3 > 1' in coercion to\n'logical(1)'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n!F==T    #! is used to represent \"not\", what it is not \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\nThe warning is apart of the new r package \n\n\n## For Loop \n\nFor loops is a fluent pathway that can help us repeat statements that we want generated until whatever condition we set is completed. I can show you a few examples below !\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndoubles<- numeric() # assign the variable to numeric function so that r knows that i is numeric \nfor (i in 1:20) # i will be representative of the variable we will use for the loop, I am using the for loop to count from 1 to 20\n  { doubles<-c(doubles, i*2)   #inside of the brackets I will reassign the doubles data frame that I just created and make i double for each number \n  \n}\ndoubles  #calling the data frame to see the results \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40\n```\n:::\n:::\n\n\n\n**break**\nbreak is to help us make a stop in the loop based on the certain condition we set. We will use the same doubles set to show this \n\n::: {.cell}\n\n```{.r .cell-code}\ndoubles<-numeric()\nfor (i in 1:20)\n{ doubles<-c(doubles, i*2) \nif(i==6)\n{break}\n}\ndoubles\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10 12\n```\n:::\n:::\n\n\nAs you can see above , once I set the condition of \"if i=6 then break\"\nThe loop would not go on any more \n\n\n##Function \n\nCreating your own function is very fun , you can tell r what you want the code to do . I will create two functions and then we are all done !\n\nLet's go !!\n\n**Function 1**\n\nFor this first function, I wanted to create a function in which it multiplies the value of a multiplied by 2 , then I tried it using the function with different values of a. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na<-numeric() # make r know that a is numeric \nmynew_function<-function(a) # assign my new function to a variable \n{return(a*2)\n}\n\n#try my new function with different a values \nmynew_function(2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nmynew_function(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\nmynew_function(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n**Function2**\n\nI can make another function for numbers indivisible or divisible by 4. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndivisible_4<- function(x,y,r) {  #name function using a name that will inform readers about what the function is for \n  x<-4\n  r<-y%%4 #using the %% logical tool you learned about earlier to give me remainder\n  \n  if (r>0) #if my remainder is more than 0 it would make the number indivisible by 4 \n    print(\"indivisible by 4\")\n  if (r==0)\n    #if my number is == to 0 , it would make it divisible  by 4 \n    print(\"divisible by 4\")\n}\n\ndivisible_4(y=16)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"divisible by 4\"\n```\n:::\n\n```{.r .cell-code}\ndivisible_4(y=17)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"indivisible by 4\"\n```\n:::\n\n```{.r .cell-code}\ndivisible_4(y=18)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"indivisible by 4\"\n```\n:::\n:::\n\n\n\nPhewww that was a lot , that is all for my midterm part 1 ! ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}